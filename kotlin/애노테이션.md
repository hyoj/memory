# 애노테이션(Annotation)

애노테이션이란 클래스나 메서드 등 코드에 추가적인 의미를 부여하는 방법이다.  
애노테이션을 사용하면 컴파일 시점이나 런타임 시점에 부가적인 처리를 할 수 있다.


## 애너테이션 선언
애노테이션을 선언하려면 `annotation`을 클래스 앞에 붙여준다.
```kotlin
annotation class Special
```

## 메타-애노테이션
애노테이션 클래스에 적용할 수 있는 애노테이션이다.  
해당 애노테이션을 어떻게 처리할지 제어하는 데 사용한다.

```kotlin
@Target(AnnoationTarget.CLASS)
annotation class Special
```

### 메타-애너테이션 종류  
`@Target`  
어떤 요소(클래스, 함수, 프로퍼티, 파라미터 등)에 적용할 수 있는지 지정한다.  
지정하지 않을 경우 모든 요소에 적용할 수 있는 애노테이션이 된다.  

`@Retention`  
애너테이션을 소스 수준에서만 유지할 지, 컴파일한 클래스에 저장할 지, 런타임에 리플렉션을 사용해서 접근할 수 있게 할지를 지정한다.  
기본 값은 런타임 시점까지 유지할 수 있도록 한다.

`@Repeatable`  
한 요소에 애노테이션이 중복으로 사용될 수 있는지를 나타낸다.

`@MustBeDocumented`  
생성한 API 문서에 해당 Annotation 도 포함될 수 있는지를 나타낸다.  
Library 를 만들 때 사용한다.  

## 애노테이션 적용하기
```kotlin
@Target(AnnoationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER)
@Repeatable
@MustBeDocumented
annotation class Special

@Special
@Special
class Foo {
    @Special
    fun hello(@Special n: Int): Int {
        return 1
    }
}
```

? @Target 에 AnnotationTarget.VALUE_PARAMETER 을 지정하지 않았다면 ?

? @Repeatable 이 없다면 ?

? @MustBeDocumented 는 언제 동작 ?

## 애노테이션 파라미터
파라미터가 있는 애노테이션을 정의하려면 주 생성자에 파라미터를 선언해야한다.  

```kotlin
annotation class Special(val why: String)

@Special("secret") class Foo {}
```

애너테이션 파라미터가 될 수 있는 타입:
- Int, Long 등 원시 타입 값
- 문자열
- Enum
- 다른 애노테이션
- 클래스 (Foo::class)
- 위에서 열거한 타입의 배열

### 애노테이션 파라미터로 애노테이션 사용하기
어떤 애노테이션의 파라미터로 애노테이션을 사용할 경우, 해당 애노테이션의 이름에 @ 문자를 접두어로 붙이지 않고 인자로 넘겨준다.  

```kotlin
annotation class ReplaceWith(val guide: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith)

@Deprecated("This function is deprecated", ReplaceWith("removeAt(index)"))
fun remove(index: Int) { ... }
```

! intellij 에서 가이드 확인 해보기 !


### 애노테이션 파라미터로 클래스 사용하기
애노테이션의 인자로 클래스를 사용하려면 코틀린 클래스(`KClass`)를 사용한다.  
`KClass`는 코틀린 클래스의 참조를 저장하는 타입이다.  

클래스를 인자로 받아야 한다면 애노테이션 파라미터 타입에 `KClass<out 허용할 클래스 이름>`을 쓴다.  
```kotlin
import kotlin.reflect.KClass

annotation class Special(val arg1: KClass<out Animal>)

@Special(Cat::class) class MyClass
```
! `<out Any>` !

### 애노테이션 파라미터로 제네릭 클래스 사용하기
애노테이션 인자로 제네릭 클래스를 받으려면 `KClass<out 허용할 제네릭 클래스 이름<*>>`처럼 허용할 제네릭 클래스의 이름 뒤에 스타 프로젝션을 덧붙인다.  

```kotlin
import kotlin.reflect.KClass

annotation class Special(val arg1: KClass<out Box<*>>)

@Special(Box::class) class MyClass
```

? `<*>` 없으면? ?
? 스타 프로젝션 ?
해당 제네릭 클래스가 어떤 타입의 값이든 받기 위해 사용한다.

! Box Generic Class 만들어 보기 !

## 애노테이션 사용 지점 대상
코틀린 코드가 바이트 코드로 변환되었을 때 여러가지 요소에 대응하는 경우,  
정확히 어떤 부분에 애노테이션을 적용할 지 지정 할 수 있다.
이를 사용 지점 대상(`use-site target`)이라 한다.

사용 지점 대상 문법
![[use-site-target.png]]

지원하는 사용 위치 대상은 다음과 같다:
- file
- property (자바에서 선언된 애노테이션에서는 이 사용 지점 대상을 사용할 수 없다.)
- field
- get (프로퍼티 getter)
- set (프로퍼티 setter)
- receiver (확장 함수나 프로퍼티의 리시버 파라미터)
- param (생성자 파라미터)
- setparam (프로퍼티 setter의 파라미터)
- delegate (위임 프로퍼티의 위임 인스턴스를 담아둔 필드)

```kotlin
@file:JvmName("Example")

package com.kotlin.demo

class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
```
! byte code 확인 !

---
Kotlin in action 도서
[Annotations | Kotlin (kotlinlang.org)](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets)