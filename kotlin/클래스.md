# 클래스
## 클래스와 메서드는 기본적으로 `final`
코틀린에는 상속을 제어하기 위한 변경자로 `open`, `final`, `abstract` 변경자가 있는데, 클래스와 메서드는 기본적으로 `final`이다.
따라서 어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다.

그와 더불어 오버라이드를 허용할 메서드나 프로퍼티 앞에도 `open` 변경자를 붙여야 한다.

```kotlin
interface Clickable {  
	fun click()  
	fun showOff() = println("I'm clickable!")  
}  
  
open class RichButton : Clickable { // 상속을 허용하는 클래스
  
	fun disable() {}  // 이 함수는 final이다. 하위 클래스가 이 메서드를 오버라이드 할 수 없다.
	
	open fun animate() {} // 하위 클래스에서 이 메서드를 오버라이드 해도 된다.  
	
	override fun click() {} // 상위 클래스에서 열려있는 메서드를 오버라이드 한다. 오버라이드한 메서드는 기본적으로 열려있다.
	// final override fun click() {} // 하위 클래스에서 오버라이드 하지 못하게 금지
}
```

오버라이드하는 메서드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면  `final`을 명시해야 한다.

### 코틀린은 왜 기본적인 상속 가능 상태를 `final`로 만들었을까?
코틀린은 취약한 기반 클래스 문제를 해결하기 위해 기본적으로 상속이 불가능하도록 만들었다.

**취약한 기반 클래스(fragile base class) 문제**
* 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.
* 자바에서는 `final` 키워드로 상속을 금지하지 않는다면 기본적으로 상속이 가능하다.
* "Effective Java"에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하여 취약한 기반 클래스 문제를 방지하라고 한다. 즉, 하위 클래스에서 오버라이드하게 의도된 클래스와 메서드가 아니라면 모두 final로 만들라는 뜻이다.
* 코틀린은 취약한 기반 클래스 문제를 해결하기 위해 기본 상속 가능 상태를 final로 만든 것이다.

**기본 상속 가능 상태 final 의 이점**
클래스의 기본적인 상속 가능상태를 final로 만듦으로써 다양한 경우에 "스마트 캐스트"를 활용할 수 있다.

>**스마트 캐스트**
>스마트 캐스트는 타입 검사 후에 변경될 수 없는 변수에만 적용 가능하다. 즉, 클래스 프로퍼티의 경우 val 이면서 커스텀 접근자가 없어야 한다. 클래스 프로퍼티가 final 이어야만 한다는 뜻이기도 하다.
>프로퍼티는 기본적으로 final 이기 때문에 고민할 필요 없이 대부분 스마트 캐스트를 활용하기 쉽다.


## 추상 클래스
코틀린에서 추상 클래스는 `abstract`를 붙여서 선언한다.
추상 클래스는 인스턴스화 할 수 없다.

추상 멤버는 항상 열려있다. 따라서 `open` 변경자를 명시할 필요가 없다.
추상 클래스에 속했더라도 비추상 함수는 기본적으로 `final`이다.  원한다면 `open`으로 오버라이드를 허용할 수 있다.

인터페이스 멤버는 항상 열려 있으며 final로 변경할 수 없다.

> 상속 관련 final, open, override, abstract 등을 한꺼번에 부르는 영어 용어는 없다. (영어로 모두 access modifier 라고 한다.)
> 책을 옮긴이가 변경자를 명시적으로 이해할 수 있게끔 아래 처럼 번역했다고 한다.
> 
> **접근 변경자(access modifier)** 또는 **가시성 변경자(visibility modifier)**: 
> public, private, protected, internal
> 
> **상속 제어 변경자**: 
> final, open, abstract, override

## 접근 변경자는 기본적으로 공개(public)
접근 변경자(또는 가시성 변경자)는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.
코틀린 접근 변경자는 `public`, `internal`, `protected`, `private`가 있다.
코틀린의 기본 가시성은 모두 공개(public)이다.

### 클래스 멤버
public - 모든 곳에서 볼 수 있다.
internal - 같은 모듈 안에서만 볼 수 있다. (모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.)
protected - 하위 클래스 안에서만 볼 수 있다. (자바에서는 같은 패키지 안에서만 볼 수 있다.)
private - 같은 클래스 안에서만 볼 수 있다.

### 최상위 선언
public - 모든 곳에서 볼 수 있다.
internal - 같은 모듈 안에서만 볼 수 있다. 
protected - 최상위 선언에 적용할 수 없다.
private - 같은 파일 안에서만 볼 수 있다.

## 1.4. 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스
중첩 클래스<sup>nested class</sup>는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다. (자바랑 다르다.)

