코틀린은 클래스 상속이나 데코레이터 같은 설계 패턴없이 클래스에 새로운 기능을 확장할 수 있다.
"확장(Extentions)"이라고 부르는 특별한 선언을 통해서 기능을 확장한다.
코틀린은 "확장 함수"와 "확장 프로퍼티"를 지원한다.

## 확장 함수
확장 함수를 선언하려면 "리시버 타입"의 이름을 접두어로 가져야 한다.
리시버 타입의 이름은 확장할 타입의 이름이다.
확장 함수에서 `this` 키워드는 리시버 객체에 대응한다.

```kotlin
fun MutableList.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this'는 List에 대응한다. 
    this[index1] = this[index2] 
    this[index2] = tmp 
}
```


## 확장 프로퍼티
코틀린은 함수와 유사하게 확장 프로퍼티를 지원한다.
```kotlin
val <T> List<T>.lastIndex: Int
    get() = size - 1
```

확장은 실제로 클래스에 멤버를 추가하지 않으므로, 지원 필드를 가진 확장 프로퍼티를 위한 효율적인 방법이 없다. 이것이 확장 프로퍼티에 대한 초기화를 허용하지 않는 이유이다.
이 기능은 명시적으로 getter/setter를 제공해서 정의할 수 있다.

```kotlin
val Foo.bar = 1 // 에러: 확장 프로퍼티에 대한 초기화는 허용하지 않는다.
```