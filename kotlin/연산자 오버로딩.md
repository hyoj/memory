# 연산자 오버로딩
어떤 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례<sup>convention</sup>이라고 부른다.

예를 들어 클래스 안에 plus라는 이름의 특별한 메서드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다.

(자바에서는 원시 타입만 산술 연산자를 사용할 수 있다. 
 또한 String 만 특별히 + 연산자를 사용할 수 있다.)


## 연산자 오버로딩 하는 방법
코틀린에서는 언어에서 미리 정해둔 연산자를 오버로딩할 수 있다.  
연산자를 오버로딩 하려면 메서드 명 앞에 `operator` 키워드를 붙여야 한다.  
연산자는 멤버 함수나, 확장 함수로 정의하면 된다.

### 단항 연산자 (Unary operator)
단항 연산자를 오버로딩하려면 다음과 같은 이름으로 메서드를 선언하면 된다.

| Expression | Translated to |
|----|----------|
| +a | a.unaryPlus() |
| -a | a.unaryMinus() |
| !a | a.not() |

```kotlin
data class Point(val x: Int, val y: Int) {
	operator fun unaryMinus(): Point {
		return Point(-x, -y)
	} 
}

val point = Point(10, 20)

fun main() {
   println(-point)  // prints "Point(x=-10, y=-20)"
}
```

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.unaryMinus() = Point(-x, -y)
```

inc나 dec 함수를 정의해 증가/감소 연산자를 오버로딩하는 경우 컴파일러는 일반적인 값에 대한 전위와 후위 증가/감소 연산자와 같은 의미를 제공한다.

| Expression | methond name |
|----|----------|
| ++a, a++ | inc |
| --a, a-- | dec |


### 이항 산술 연산자 (Binary operator)
이항 산술 연산자를 오버로딩하려면 다음과 같은 이름으로 메서드를 정의하면 된다.

| Expression | Translated to |
|----|----------|
| a * b | a.times(b) |
| a / b | a.div(b) |
| a % b | a.rem(b) |
| a + b | a.plus(b) |
| a - b | a.minus(b) |
| a..b | a.rangeTo(b) |

이 때 두 피연산자가 같은 타입일 필요는 없다.
또한 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치하지 않아도 된다.

연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다.
`*`, `/`, `%`는 모두 우선순위가 같고, 이 셋의 우선순위는 `+`, `-` 연산자보다 높다.

### 복합 대입 연산자 오버로딩
+=, -= 등의 연산자는 복합 대입<sup>compound assignment</sup> 연산자라고 불린다.
반환 타입이 Unit인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 그 함수를 사용한다. 

그런데, plus와 같은 연산자를 오버로딩하면 +연산자와 +=연산자도 자동으로 함께 지원한다.
따라서 plus와 plusAssign 연산을 동시에 정의하지 말아야 한다.
어떤 클래스가 이 두 함수를 모두 정의하고 둘 다 +=에 사용가능한 경우 컴파일러는 오류를 보고한다.

기억해야 할 점!
+와 -는 항상 새로운 컬렉션을 반환하며,  
+=와 -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다.

## 비교 연산자 오버로딩
코틀린에서는 모든 객체에 대해 비교 연산을 수행할 수 있다.
코틀린에서는 == 비교 연산자를 직접 사용할 수 있다. 
(자바에서는 비교를 위해 equals나 compareTo를 호출해야 한다.)

 코틀린의 equals 함수는 Any에 정의된 메서드이므로 동등성 비교를 모든 객체에 대해 적용할 수 있다.

상위 클래스의 operator 지정 메서드는 하위 클래스에서 오버라이딩 하면 자동으로 적용된다.   

Any에 정의된 equals에는 operator 변경자가 붙어있다.
즉, 모든 클래스의 부모인 Any의 equals에 operator 변경자가 붙어 있으므로 equals 메서드를 오버라이딩할 때는 operator 변경자가 없더라도 적용된다.

+상속받은 멤버 함수가 확장 함수보다 우선순위가 높다. 따라서 equals를 확장 함수로는 정의할 수 없다.


### 동등성 연산자: equals
코틀린은 == 연산자 호출을 equals 메서드 호출로 컴파일한다.  
!= 연산자를 사용하는 식도 equals 호출로 컴파일 된다.  

클래스에 data 표시가 붙어있으면 컴파일러가 자동으로 equals를 생성해주는데, 직접 equals를 구현한다면 다음과 비슷한 코드가 된다.  
```kotlin
class Point(val x: Int, val y: Int) {  
	override fun equals(obj: Any?): Boolean { // Any에 정의된 메서드 오버라이딩
		if (obj === this) return true // 최적화: 파라미터가 this와 같은 객체면 바로 반환
		if (obj !is Point) return false // 파라미터 타입 검사, 스마트 캐스트 
		return obj.x == x && obj.y == y // 스마트 캐스트를 통해 x와 y 프로퍼티에 접근
	}
}
```

`===` 식별자 비교<sup>identity equals</sup> 연산자는 자바의 `==` 연산자와 같다.  
즉, 코틀린에서 `===`는 자신의 두 피연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교한다.  

또한 `===`는 연산자 오버로딩이 불가능하다.  []()