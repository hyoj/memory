# 연산자 오버로딩
어떤 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례<sup>convention</sup>이라고 부른다.

예를 들어 클래스 안에 plus라는 이름의 특별한 메서드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다.

코틀린에서 이런 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다.
기존 자바 클래스에 대해 확장 함수를 구현하면서 관례에 따라 이름을 붙이면 기존 자바 코드를 바꾸지 않아도 새로운 기능을 쉽게 부여할 수 있다.

코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자다.
자바에서는 원시 타입과 String에 대해서 + 연산자를 사용할 수 있다.

하지만 BigInteger 클래스를 다루는 것을 생각해보면
add 메서드를 명시적으로 호출하는 것 보다 + 연산자를 사용하는 편이 더 간편할 수 있다.
코틀린에서는 이런식으로 +, += 연산자를 사용할 수 있는데, 어떻게 클래스에 대한 일반 산술 연산자를 정의할 수 있는지 살펴보자.

## 연산자 오버로딩 하는 방법
연산자를 오버로딩 하려면 메서드 명 앞에 `operator` 키워드를 붙여야 한다.

코틀린에서는 언어에서 미리 정해둔 연산자만 오버로딩할 수 있다.
관례에 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다.

또한 일반 함수와 마찬가지로 operator 함수도 오버로딩할 수 있다.
따라서 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다.

### 단항 연산자 (Unary operator)
단항 연산자를 오버로딩하려면 다음과 같은 이름으로 메서드를 선언하면 된다.

| Expression | Translated to |
|----|----------|
| +a | a.unaryPlus() |
| -a | a.unaryMinus() |
| !a | a.not() |

```kotlin
data class Point(val x: Int, val y: Int) {
	operator fun unaryMinus(): Point {
		return Point(-x, -y)
	} 
}

val point = Point(10, 20)

fun main() {
   println(-point)  // prints "Point(x=-10, y=-20)"
}
```

연산자를 멤버 함수로 만드는 대신 확장 함수로 정의할 수도 있다.
```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.unaryMinus() = Point(-x, -y)
```

inc나 dec 함수를 정의해 증가/감소 연산자를 오버로딩하는 경우 컴파일러는 일반적인 값에 대한 전위와 후위 증가/감소 연산자와 같은 의미를 제공한다.

| Expression | methond name |
|----|----------|
| ++a, a++ | inc |
| --a, a-- | dec |


### 이항 산술 연산자 (Binary operator)
이항 산술 연산자를 오버로딩하려면 다음과 같은 이름으로 메서드를 정의하면 된다.

| Expression | Translated to |
|----|----------|
| a * b | a.times(b) |
| a / b | a.div(b) |
| a % b | a.rem(b) |
| a + b | a.plus(b) |
| a - b | a.minus(b) |
| a..b | a.rangeTo(b) |

이 때 두 피연산자가 같은 타입일 필요는 없다.
또한 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치하지 않아도 된다.

연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선수위와 같다.
`*`, `/`, `%`는 모두 우선순위가 같고, 이 셋의 우선순위는 `+`, `-` 연산자보다 높다.

### 복합 대입 연산자 오버로딩
+=, -= 등의 연산자는 복합 대입<sup>compound assignment</sup> 연산자라고 불린다.
반환 타입이 Unit인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 그 함수를 사용한다. 

그런데, plus와 같은 연산자를 오버로딩하면 +연산자와 +=연산자도 자동으로 함께 지원한다.
따라서 plus와 plusAssign 연산을 동시에 정의하지 말아야 한다.
어떤 클래스가 이 두 함수를 모두 정의하고 둘 다 +=에 사용가능한 경우 컴파일러는 오류를 보고한다.

기억해야 할 점!
+와 -는 항상 새로운 컬렉션을 반환하며,  
+=와 -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다.

## 비교 연산자 오버로딩
코틀린에서는 모든 객체에 대해 비교 연산을 수행할 수 있다.
자바에서는 equals나 compareTo를 호출해야 했지만, 코틀린에서는 == 비교 연산자를 직접 사용할 수 있다.

### 동등성 연산자: equals
코틀린은 == 연산자 호출을 equals 메서드 호출로 컴파일한다. 이것도 바로 관례가 적용되어있던 것이다.
!= 연산자를 사용하는 식도 equals 호출로 컴파일 된다.

클래스에 data 표시가 붙어있으면 컴파일러가 자동으로 equals를 생성해주는데, 직접 equals를 구현한다면 다음과 비슷한 코드가 된다.
```kotlin
class Point(val x: Int, val y: Int) {  
	override fun equals(obj: Any?): Boolean { // Any에 정의된 메서드 오버라이딩
		if (obj === this) return true // 최적화: 파라미터가 this와 같은 객체면 바로 반환
		if (obj !is Point) return false // 파라미터 타입 검사, 스마트 캐스트 
		return obj.x == x && obj.y == y // 스마트 캐스트를 통해 x와 y 프로퍼티에 접근
	}
}
```

`===` 식별자 비교<sup>identity equals</sup> 연산자는 자바의 `==` 연산자와 같다.  
즉, 코틀린에서 `===`는 자신의 두 피연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교한다.

또한 `===`는 연산자 오버로딩이 불가능하다.

 equals 함수는 Any에 정의된 메서드이므로 동등성 비교를 모든 코틀린 객체에 대해 적용할 수 있다.

Any에 정의된 equals에는 operator 변경자가 붙어있다.
Any에서 상속받은 equals가 확장 함수보다 우선순위가 높다. 따라서 equals를 확장 함수로 정의할 수 없다.
상위 클래스의 operator 지정 메서드는 하위 클래스에서 오버라이딩 하면 자동으로 적용된다.   
즉, 모든 클래스의 부모인 Any의 equals에 operator 변경자가 붙어 있으므로 equals 메서드를 오버라이딩할 때는 operator 변경자가 없더라도 적용된다.